<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫之木落</title>
  
  <subtitle>你还有很多未完成的梦，还有什么理由停下脚步......</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lookk.cn/"/>
  <updated>2017-12-09T09:30:13.027Z</updated>
  <id>http://www.lookk.cn/</id>
  
  <author>
    <name>枫之木落</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo 设置网站小图表</title>
    <link href="http://www.lookk.cn/2017/12/09/hexo-%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%AB%99%E5%B0%8F%E5%9B%BE%E8%A1%A8/"/>
    <id>http://www.lookk.cn/2017/12/09/hexo-设置网站小图表/</id>
    <published>2017-12-09T09:24:56.000Z</published>
    <updated>2017-12-09T09:30:13.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20171209172004775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>如图，设置这样的网站小图片，有多种方法，我介绍一直简单的，到ico在线制作生成一个ico图片，命名为favicon.ico，放在hexo/source下上传，然后设置yilia下的_config.yml的favicon: favicon.ico，然后更新github就行了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171209172004775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize
      
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>heox 添加音乐测试</title>
    <link href="http://www.lookk.cn/2017/12/09/heox-%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.lookk.cn/2017/12/09/heox-添加音乐测试/</id>
    <published>2017-12-09T08:34:15.000Z</published>
    <updated>2017-12-09T08:34:15.630Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo yilia 主题使用畅言评论系统</title>
    <link href="http://www.lookk.cn/2017/12/09/Hexo-yilia-%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.lookk.cn/2017/12/09/Hexo-yilia-主题使用畅言评论系统/</id>
    <published>2017-12-09T08:31:10.000Z</published>
    <updated>2017-12-09T08:32:07.757Z</updated>
    
    <content type="html"><![CDATA[<p>前言：你的有一个可以正常使用的域名，可以参考我的<a href="http://www.lookk.cn/2017/12/09/hexo-%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/">hexo 绑定自己的域名</a></p><h3 id="注册畅言"><a href="#注册畅言" class="headerlink" title="注册畅言"></a>注册畅言</h3><p>进入<a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言官网</a> 免费注册</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>注册完后，登录进入畅言官网，获取你的畅言 app id 和 app key。<br>把你的ip和key添加到hexo下的_config.yml的畅言配置里就行了，yilia主题把一切都封装好了，直接使用就行。<br>只要在发布篇文章添加上可评论：<code>comments: true</code> #就行了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：你的有一个可以正常使用的域名，可以参考我的&lt;a href=&quot;http://www.lookk.cn/2017/12/09/hexo-%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/&quot;&gt;he
      
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 绑定自己的域名</title>
    <link href="http://www.lookk.cn/2017/12/09/hexo-%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/"/>
    <id>http://www.lookk.cn/2017/12/09/hexo-绑定自己的域名/</id>
    <published>2017-12-09T08:14:55.000Z</published>
    <updated>2017-12-09T08:19:54.379Z</updated>
    
    <content type="html"><![CDATA[<p>前提，你得有一个域名，有些域名需要备案后才能用。</p><h3 id="在域名解析添加记录"><a href="#在域名解析添加记录" class="headerlink" title="在域名解析添加记录"></a>在域名解析添加记录</h3><p>如果你用你顶点域名（如：lookk.cn)，就添加一条主机记录为@的，如果你用www子域名（如：www.look.cn）,github绑定自己的域名只支持这两种，不支持其他子域名，你可以去github的help查看</p><p><img src="http://img.blog.csdn.net/20171209155658980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>记录类型一定要为 CNAME 这种类型，只有这样你的域名才能指向你的github </li><li>记录值填 yourname.github.io </li></ul><a id="more"></a><h3 id="在github添加自定义域名"><a href="#在github添加自定义域名" class="headerlink" title="在github添加自定义域名"></a>在github添加自定义域名</h3><p><img src="http://img.blog.csdn.net/20171209160451717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p><h3 id="配置hexo的-config-yml"><a href="#配置hexo的-config-yml" class="headerlink" title="配置hexo的_config.yml"></a>配置hexo的_config.yml</h3><p>找到url设置，添加你的域名<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL 链接设置</span><br><span class="line">## If your site <span class="keyword">is</span> <span class="keyword">put</span> in <span class="keyword">a</span> subdirectory, <span class="keyword">set</span> url <span class="keyword">as</span> <span class="string">'http://yoursite.com/child'</span> <span class="built_in">and</span> root <span class="keyword">as</span> <span class="string">'/child/'</span></span><br><span class="line">ur<span class="variable">l:</span> http://www.lookk.<span class="keyword">cn</span></span><br><span class="line">roo<span class="variable">t:</span> /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_default<span class="variable">s:</span></span><br></pre></td></tr></table></figure></p><h3 id="上传CNAME文件"><a href="#上传CNAME文件" class="headerlink" title="上传CNAME文件"></a>上传CNAME文件</h3><p>光执行上面三个步骤还是不够，每次你上传更新时，你在github设置的域名可能会丢失，所以要上传一个CNAME文件，让github记住你添加的域名：<br>先创建一个名为CNAME的文件，没有后缀，再在文件中写上你的域名（如：www.lookk.cn）,然后把这个文件放在/hexo/source目录下，上传就行了。</p><p>摘自：<a href="http://www.flyfood.name/2017/07/23/%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B93/" target="_blank" rel="noopener">http://www.flyfood.name/2017/07/23/%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B93/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前提，你得有一个域名，有些域名需要备案后才能用。&lt;/p&gt;
&lt;h3 id=&quot;在域名解析添加记录&quot;&gt;&lt;a href=&quot;#在域名解析添加记录&quot; class=&quot;headerlink&quot; title=&quot;在域名解析添加记录&quot;&gt;&lt;/a&gt;在域名解析添加记录&lt;/h3&gt;&lt;p&gt;如果你用你顶点域名（如：lookk.cn)，就添加一条主机记录为@的，如果你用www子域名（如：www.look.cn）,github绑定自己的域名只支持这两种，不支持其他子域名，你可以去github的help查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171209155658980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录类型一定要为 CNAME 这种类型，只有这样你的域名才能指向你的github &lt;/li&gt;
&lt;li&gt;记录值填 yourname.github.io &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo yilia主题添加文章访问量统计</title>
    <link href="http://www.lookk.cn/2017/12/09/hexo-yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1/"/>
    <id>http://www.lookk.cn/2017/12/09/hexo-yilia主题添加文章访问量统计/</id>
    <published>2017-12-09T07:32:48.000Z</published>
    <updated>2017-12-09T07:34:29.033Z</updated>
    
    <content type="html"><![CDATA[<p>hexo添加访问量统计功能可以用<strong>百度的站长统计</strong>、<strong>leancloud</strong>，还有<strong>不蒜子</strong>，这里我用的不蒜子，感觉挺简单的。</p><h3 id="引入不蒜子"><a href="#引入不蒜子" class="headerlink" title="引入不蒜子"></a>引入<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里，我用的yilia主题，放在/themes/yilia/layout/_partial/footer.ejs<br><a id="more"></a></p><h3 id="添加站点访问量"><a href="#添加站点访问量" class="headerlink" title="添加站点访问量"></a>添加站点访问量</h3><p>通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span> </span><br><span class="line">  本站访客数<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人次</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>计算访问量的方法有两种：<br>算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。<br>算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。<br>我用的是uv的方式，大家自行选择即可。</p><h3 id="添加文章访问量"><a href="#添加文章访问量" class="headerlink" title="添加文章访问量"></a>添加文章访问量</h3><p>文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span>&gt;</span></span><br><span class="line">   本文总阅读量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们直接就这样放在yilia主题中，首页也会显示该网页的访问量，没法正常使用，所以我加一个判断，如果是首页不显示该文章的访问量，下面这段代码添加在/themes/yilia/layout/_partial/article.ejs的header的日期后面：</p><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="perl"> <span class="keyword">if</span> ( !<span class="keyword">index</span> )&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"archive-article-date"</span>&gt;</span></span></span><br><span class="line"><span class="xml">阅读量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="perl"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure><p>摘自：<a href="http://www.jianshu.com/p/8a8f880f40c0" target="_blank" rel="noopener">http://www.jianshu.com/p/8a8f880f40c0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo添加访问量统计功能可以用&lt;strong&gt;百度的站长统计&lt;/strong&gt;、&lt;strong&gt;leancloud&lt;/strong&gt;，还有&lt;strong&gt;不蒜子&lt;/strong&gt;，这里我用的不蒜子，感觉挺简单的。&lt;/p&gt;
&lt;h3 id=&quot;引入不蒜子&quot;&gt;&lt;a href=&quot;#引入不蒜子&quot; class=&quot;headerlink&quot; title=&quot;引入不蒜子&quot;&gt;&lt;/a&gt;引入&lt;a href=&quot;http://busuanzi.ibruce.info/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不蒜子&lt;/a&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里，我用的yilia主题，放在/themes/yilia/layout/_partial/footer.ejs&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo yilia主题的所有文章功能不能用</title>
    <link href="http://www.lookk.cn/2017/12/08/hexo-yilia%E4%B8%BB%E9%A2%98%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E5%8A%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8/"/>
    <id>http://www.lookk.cn/2017/12/08/hexo-yilia主题的所有文章功能不能用/</id>
    <published>2017-12-08T14:05:29.000Z</published>
    <updated>2017-12-08T14:29:12.970Z</updated>
    
    <content type="html"><![CDATA[<p>1、node.js版本必须6.2以上<br>2、在hexo根目录下执行命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> hexo-generator-json-<span class="attribute">content</span> --save</span><br></pre></td></tr></table></figure><a id="more"></a><p>3、在hexo的配置文件_config.yml最后添加<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">    meta:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    pages:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    posts:</span></span><br><span class="line"><span class="attr">      title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      text:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      raw:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      content:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      slug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      updated:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      permalink:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      excerpt:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      categories:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>添加后 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 就行了。</p><blockquote><p>这些在如果所有文件给你不能正常使用会显示，我在这写是提示大家添加位置和添加内容的排版不能动，这是hexo的语法。这个所以文章功能个人感觉写的挺不错，自带搜索功能</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、node.js版本必须6.2以上&lt;br&gt;2、在hexo根目录下执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm &lt;span class=&quot;selector-tag&quot;&gt;i&lt;/span&gt; hexo-generator-json-&lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt; --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 配置yilia主题</title>
    <link href="http://www.lookk.cn/2017/12/08/hexo-%E9%85%8D%E7%BD%AEyilia%E4%B8%BB%E9%A2%98/"/>
    <id>http://www.lookk.cn/2017/12/08/hexo-配置yilia主题/</id>
    <published>2017-12-08T13:50:13.000Z</published>
    <updated>2017-12-08T13:52:23.621Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：</strong><br>主题网站：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>我试了好几个主题，有的不能用，有的不太好看，最后选择了yilia主题，这个挺好配的。<br>yilia主题网址：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a><br>要求node.js版本在6.2以上</p><h3 id="下载安装yilia主题"><a href="#下载安装yilia主题" class="headerlink" title="下载安装yilia主题"></a>下载安装yilia主题</h3><p><strong>安装</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure></p><p><strong>配置</strong><br>修改hexo根目录下的 _config.yml ： <code>theme: yilia</code><br>然后配置yilia文件下的_config.yml（目录：<code>hexo/themes/yilia/_config.yml</code>） 配置文件<br><a id="more"></a><br>这是我的可以参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Header</span></span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  主页: /</span><br><span class="line">  归档: /archives</span><br><span class="line"><span class="meta">  #</span><span class="bash">分类: /categories</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">标签: /tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SubNav</span></span><br><span class="line">subnav:</span><br><span class="line">  github: "https://github.com/jiaoxiangyu"</span><br><span class="line"><span class="meta">  #</span><span class="bash">weibo: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">rss: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">zhihu: <span class="string">"#"</span></span></span><br><span class="line">  qq: "/information"</span><br><span class="line"><span class="meta">  #</span><span class="bash">weixin: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">jianshu: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">douban: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">segmentfault: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">bilibili: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">acfun: <span class="string">"#"</span></span></span><br><span class="line">  mail: "/information"</span><br><span class="line"><span class="meta">  #</span><span class="bash">facebook: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">google: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">twitter: <span class="string">"#"</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">linkedin: <span class="string">"#"</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">rss: /atom.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否需要修改 root 路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</span></span><br><span class="line">root: /</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Content</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文章太长，截断按钮文字</span></span><br><span class="line">excerpt_link: more</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文章卡片右下角常驻链接，不需要请设置为<span class="literal">false</span></span></span><br><span class="line">show_all_link: '展开全文'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数学公式</span></span><br><span class="line">mathjax: false</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否在新窗口打开链接</span></span><br><span class="line">open_in_new: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打赏</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打赏<span class="built_in">type</span>设定：0-关闭打赏； 1-文章对应的md文件里有reward:<span class="literal">true</span>属性，才有打赏； 2-所有文章均有打赏</span></span><br><span class="line">reward_type: 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打赏wording</span></span><br><span class="line">reward_wording: '谢谢你请我吃糖果'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</span></span><br><span class="line">alipay: </span><br><span class="line"><span class="meta">#</span><span class="bash"> 微信二维码图片地址</span></span><br><span class="line">weixin: </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:<span class="literal">true</span>属性，才有目录； 2-所有文章均显示目录</span></span><br><span class="line">toc: 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为<span class="literal">true</span>即可隐藏hexo重复的序号；否则置为<span class="literal">false</span></span></span><br><span class="line">toc_hide_index: true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录为空时的提示</span></span><br><span class="line">toc_empty_wording: '目录，不存在的…'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否有快速回到顶部的按钮</span></span><br><span class="line">top: true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Miscellaneous</span></span><br><span class="line">baidu_analytics: ''</span><br><span class="line">google_analytics: ''</span><br><span class="line">favicon: /favicon.png</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">你的头像url</span></span><br><span class="line">avatar: /img/header.jpg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">是否开启分享</span></span><br><span class="line">share_jia: true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不需要使用某项，直接设置值为<span class="literal">false</span>，或注释掉</span></span><br><span class="line"><span class="meta">#</span><span class="bash">具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">1、多说</span></span><br><span class="line">duoshuo: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2、网易云跟帖</span></span><br><span class="line">wangyiyun: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3、畅言</span></span><br><span class="line">changyan_appid: *** #这个畅言id和conf写自己的</span><br><span class="line">changyan_conf: ***</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的</span></span><br><span class="line">disqus: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5、Gitment</span></span><br><span class="line">gitment_owner: false      #你的 GitHub ID</span><br><span class="line">gitment_repo: ''          #存储评论的 repo</span><br><span class="line">gitment_oauth:</span><br><span class="line">  client_id: ''           #client ID</span><br><span class="line">  client_secret: ''       #client secret</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 样式定制 - 一般不需要修改，除非有很强的定制欲望…</span></span><br><span class="line">style:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 头像上面的背景颜色</span></span><br><span class="line">  header: '#4d4d4d'</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 右滑板块背景</span></span><br><span class="line">  slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> slider的设置</span></span><br><span class="line">slider:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 是否默认展开tags板块</span></span><br><span class="line">  showTags: false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 智能菜单</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如不需要，将该对应项置为<span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如</span></span><br><span class="line"><span class="meta">#</span><span class="bash">smart_menu:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  friends: <span class="literal">false</span></span></span><br><span class="line">smart_menu:</span><br><span class="line">  innerArchive: '所有文章'</span><br><span class="line">  friends: '友链'</span><br><span class="line">  aboutme: '关于我'</span><br><span class="line"></span><br><span class="line">friends:</span><br><span class="line"><span class="meta">  #</span><span class="bash">友情链接1: http://localhost:4000/</span></span><br><span class="line">  我的csdn博客: http://blog.csdn.net/qq_32337109</span><br><span class="line">  飞翔的美食号: http://www.flyfood.name</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</span></span><br><span class="line">aboutme: </span><br><span class="line">  程序猿一枚&lt;br&gt;</span><br><span class="line">  还是枚很笨的程序猿</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  这个网站只是个人学习笔记，如有错误欢迎指点。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;主题网站：&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/themes/&lt;/a&gt;&lt;br&gt;我试了好几个主题，有的不能用，有的不太好看，最后选择了yilia主题，这个挺好配的。&lt;br&gt;yilia主题网址：&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/litten/hexo-theme-yilia&lt;/a&gt;&lt;br&gt;要求node.js版本在6.2以上&lt;/p&gt;
&lt;h3 id=&quot;下载安装yilia主题&quot;&gt;&lt;a href=&quot;#下载安装yilia主题&quot; class=&quot;headerlink&quot; title=&quot;下载安装yilia主题&quot;&gt;&lt;/a&gt;下载安装yilia主题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;https&lt;/span&gt;://github.com/litten/hexo-theme-yilia.git themes/yilia&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;br&gt;修改hexo根目录下的 _config.yml ： &lt;code&gt;theme: yilia&lt;/code&gt;&lt;br&gt;然后配置yilia文件下的_config.yml（目录：&lt;code&gt;hexo/themes/yilia/_config.yml&lt;/code&gt;） 配置文件&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 首页文章只显示一部分</title>
    <link href="http://www.lookk.cn/2017/12/08/hexo-%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0%E5%8F%AA%E6%98%BE%E7%A4%BA%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>http://www.lookk.cn/2017/12/08/hexo-首页文章只显示一部分/</id>
    <published>2017-12-08T13:23:32.000Z</published>
    <updated>2017-12-08T13:27:39.123Z</updated>
    
    <content type="html"><![CDATA[<p>这个只要在文章中加上<code>&lt;!--more--&gt;</code> 标记 ，该标记以后部分就不在显示了，只有展开全部才显示，这是hexo定义的。<br>这样每次添加这个标记有点麻烦，也可以自定义添加，不过可能会导致排版错乱，自定义配置链接<a href="https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/" target="_blank" rel="noopener">https://twiceyuan.com/2014/05/25/hexo%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0readmore%E6%A0%87%E8%AE%B0/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个只要在文章中加上&lt;code&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 标记 ，该标记以后部分就不在显示了，只有展开全部才显示，这是hexo定义的。&lt;br&gt;这样每次添加这个标记有点麻烦，也可以自定义添加，不过可能会导致排版错乱，自定义配置链接&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 创建文章、标签、分类</title>
    <link href="http://www.lookk.cn/2017/12/08/hexo-%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0%E3%80%81%E6%A0%87%E7%AD%BE%E3%80%81%E5%88%86%E7%B1%BB/"/>
    <id>http://www.lookk.cn/2017/12/08/hexo-创建文章、标签、分类/</id>
    <published>2017-12-08T13:17:14.000Z</published>
    <updated>2017-12-08T13:19:14.475Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、创建文章"><a href="#1、创建文章" class="headerlink" title="1、创建文章"></a>1、创建文章</h3><h4 id="a-在hexo下创建一个新的文章"><a href="#a-在hexo下创建一个新的文章" class="headerlink" title="a.在hexo下创建一个新的文章"></a>a.在hexo下创建一个新的文章</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heox <span class="keyword">new</span> <span class="string">"文章名称"</span></span><br></pre></td></tr></table></figure><p>生产后会提示你文件路径，一般在hexo/source/_posts下</p><h4 id="b-文章基本设置"><a href="#b-文章基本设置" class="headerlink" title="b.文章基本设置"></a>b.文章基本设置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">CentOS7下Tomcat启动慢的原因及解决方案</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-12</span><span class="bullet">-02</span> <span class="number">21</span><span class="string">:01:24</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span> <span class="comment">#是否可评论</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span> <span class="comment">#是否显示文章目录</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">"云服务器"</span> <span class="comment">#分类</span></span><br><span class="line"><span class="attr">tags:</span>   <span class="comment">#标签</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">centOS</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">tomcat</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、创建标签"><a href="#2、创建标签" class="headerlink" title="2、创建标签"></a>2、创建标签</h3><h4 id="a-创建标签页面"><a href="#a-创建标签页面" class="headerlink" title="a.创建标签页面"></a>a.创建标签页面</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure><h4 id="b-基本设置"><a href="#b-基本设置" class="headerlink" title="b.基本设置"></a>b.基本设置</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span> tags</span><br><span class="line"><span class="symbol">date:</span> <span class="number">2017</span><span class="number">-12</span><span class="number">-02</span> <span class="number">21</span>:<span class="number">01</span>:<span class="number">24</span></span><br><span class="line"><span class="symbol">type:</span> <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><h3 id="3、创建分类"><a href="#3、创建分类" class="headerlink" title="3、创建分类"></a>3、创建分类</h3><h4 id="a-创建分类页面"><a href="#a-创建分类页面" class="headerlink" title="a.创建分类页面"></a>a.创建分类页面</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>categories</span><br></pre></td></tr></table></figure><h4 id="b-基本设置-1"><a href="#b-基本设置-1" class="headerlink" title="b.基本设置"></a>b.基本设置</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span> categories</span><br><span class="line"><span class="symbol">date:</span> <span class="number">2017</span><span class="number">-12</span><span class="number">-02</span> <span class="number">21</span>:<span class="number">01</span>:<span class="number">24</span></span><br><span class="line"><span class="symbol">type:</span> <span class="string">"categories"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、创建文章&quot;&gt;&lt;a href=&quot;#1、创建文章&quot; class=&quot;headerlink&quot; title=&quot;1、创建文章&quot;&gt;&lt;/a&gt;1、创建文章&lt;/h3&gt;&lt;h4 id=&quot;a-在hexo下创建一个新的文章&quot;&gt;&lt;a href=&quot;#a-在hexo下创建一个新的文章&quot; class=&quot;headerlink&quot; title=&quot;a.在hexo下创建一个新的文章&quot;&gt;&lt;/a&gt;a.在hexo下创建一个新的文章&lt;/h4&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;heox &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;文章名称&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生产后会提示你文件路径，一般在hexo/source/_posts下&lt;/p&gt;
&lt;h4 id=&quot;b-文章基本设置&quot;&gt;&lt;a href=&quot;#b-文章基本设置&quot; class=&quot;headerlink&quot; title=&quot;b.文章基本设置&quot;&gt;&lt;/a&gt;b.文章基本设置&lt;/h4&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;title:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;CentOS7下Tomcat启动慢的原因及解决方案&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;date:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt;&lt;span class=&quot;bullet&quot;&gt;-12&lt;/span&gt;&lt;span class=&quot;bullet&quot;&gt;-02&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:01:24&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;comments:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#是否可评论&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;toc:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#是否显示文章目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;categories:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;云服务器&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#分类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;tags:&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;#标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;centOS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;tomcat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下搭建Hexo+github博客</title>
    <link href="http://www.lookk.cn/2017/12/07/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BAHexo-github%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.lookk.cn/2017/12/07/CentOS下搭建Hexo-github博客/</id>
    <published>2017-12-07T14:37:58.000Z</published>
    <updated>2017-12-08T14:13:29.953Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><blockquote><p>以前我一直用csdn博客，没有搭建自己的网站，感觉如果自己的服务器重装系统后，东西都没有了，而且csdn用着感觉还行，就不想麻烦了。前段时间我的写了一篇博客，怎么也提交不上去，而且经常出现无法提交现象，所以就觉得是时候搭建自己的博客网站了。好了不废话了，开始吧。。。</p></blockquote><a id="more"></a><h3 id="1、安装安装Node-js"><a href="#1、安装安装Node-js" class="headerlink" title="1、安装安装Node.js"></a>1、安装安装Node.js</h3><h4 id="a-下载"><a href="#a-下载" class="headerlink" title="a.下载"></a>a.下载</h4><p>找到最新的下载地址，用wget命令下载到本地<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v9.<span class="number">0.0</span>/<span class="keyword">node</span><span class="title">-v9</span>.<span class="number">0.0</span>-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：安装新一点的版本，自己去<a href="https://nodejs.org/dist查看，也不要安装最新的，可能有问题，但也不能太老，我开始因为版本太低好多功能不能实现" target="_blank" rel="noopener">https://nodejs.org/dist查看，也不要安装最新的，可能有问题，但也不能太老，我开始因为版本太低好多功能不能实现</a></p></blockquote><h4 id="b-解压命令"><a href="#b-解压命令" class="headerlink" title="b.解压命令"></a>b.解压命令</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d <span class="keyword">node</span><span class="title">-v9</span>.<span class="number">0.0</span>-linux-x64.tar.xz  //解压为tar文件</span><br><span class="line"> tar -xvf <span class="keyword">node</span><span class="title">-v9</span>.<span class="number">0.0</span>-linux-x64.tar</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvJf <span class="keyword">node</span><span class="title">-v9</span>.<span class="number">0.0</span>-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>文件就被解压到当前文件夹下了，然后移动</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv  <span class="keyword">node</span><span class="title">-v9</span>.<span class="number">0.0</span>-linux-x64 <span class="keyword">node</span><span class="title">-v9</span>.<span class="number">0.0</span></span><br><span class="line">mv  <span class="keyword">node</span><span class="title">-v9</span>.<span class="number">0.0</span> /usr/local/<span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure><h4 id="c-配置环境变量"><a href="#c-配置环境变量" class="headerlink" title="c.配置环境变量"></a>c.配置环境变量</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑 /etc/profile (使用vim)</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在底部添加 PATH 变量</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:/usr/local/node/bin</span><br><span class="line"><span class="comment"># 保存退出，先按exit键，再按shift+：</span></span><br><span class="line">wq</span><br><span class="line"><span class="comment"># 最后保存并使其生效即可</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="2、安装Hexo"><a href="#2、安装Hexo" class="headerlink" title="2、安装Hexo"></a>2、安装Hexo</h3><h4 id="a-安装hexo"><a href="#a-安装hexo" class="headerlink" title="a.安装hexo"></a>a.安装hexo</h4><p>我直接安装在root根目录了，你可以自己选择安装目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line">mkdir hexo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">cd hexo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装Git(已安装可跳过)</span></span><br><span class="line">yum install git-core</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 Hexo</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化 Hexo</span></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><h4 id="b-安装插件"><a href="#b-安装插件" class="headerlink" title="b.安装插件"></a>b.安装插件</h4><p>我现在看别人博客才发现我没有安装这些插件，我用yilia主题没有安装这些插件也可以正常使用。建议安装吧。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">archive</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">category</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-tag <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-<span class="keyword">server</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-heroku <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-rsync <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-openshift <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-stylus <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><h4 id="c-修改Hexo配置文件"><a href="#c-修改Hexo配置文件" class="headerlink" title="c.修改Hexo配置文件"></a>c.修改Hexo配置文件</h4><blockquote><p>注意：key对应没有值的时候，冒号后面一定要有空格！否则会报错<br>例如: timezone:会报错，timezone: 则不会。</p></blockquote><p>这是我的配置文件，在hexo/_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site 站点信息设置</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">枫之木落</span> <span class="comment">#站名</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">你还有很多未完成的梦，还有什么理由停下脚步......</span> <span class="comment">#副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment">#站描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">枫之木落</span> <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 链接设置</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://www.lookk.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory 文件目录</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing 文章</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format 日期</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination 分页</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions 扩展</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">yilia</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment 这里设置了Git获</span></span><br><span class="line"><span class="comment">#这里一定要注意不要写错了，否则部署到Github上会出问题</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:jiaoxiangyu/jiaoxiangyu.github.io.git</span>    </span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">'站点更新:<span class="template-variable">&#123;&#123;now("YYYY-MM-DD HH/mm/ss")&#125;&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#yilia主题加的配置  </span></span><br><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">    meta:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    pages:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    posts:</span></span><br><span class="line"><span class="attr">      title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      text:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      raw:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      content:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      slug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      updated:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      permalink:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      excerpt:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      categories:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3、部署到GitHub"><a href="#3、部署到GitHub" class="headerlink" title="3、部署到GitHub"></a>3、部署到GitHub</h3><p>前面已经安装过git了，我们要注册一个github账号</p><p>可以在hexo目录下执行这些命令：</p><h4 id="a-登录github"><a href="#a-登录github" class="headerlink" title="a.登录github"></a>a.登录github</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"you@example.com"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br></pre></td></tr></table></figure><h4 id="b-生成SSH秘钥"><a href="#b-生成SSH秘钥" class="headerlink" title="b.生成SSH秘钥"></a>b.生成SSH秘钥</h4><p>先确定你的VPS 有没有生成过ssh的key，<br>验证<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less  ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span><br></pre></td></tr></table></figure></p><p><strong>如果报错</strong><br>执行下面代码<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -C后面跟住你在github的用户名邮箱，这样公钥才会被github认可</span></span><br><span class="line"> ssh-keygen -t rsa -C example<span class="variable">@126</span>.com</span><br><span class="line"><span class="comment"># 查看 公钥内容 稍后加入Github 账户的 sshkey中</span></span><br><span class="line"> less ~<span class="regexp">/.ssh/id</span>_rsa.pub</span><br></pre></td></tr></table></figure></p><p>你会看到一堆代码</p><p><strong>如果没有报错</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -C后面跟住你在github的用户名邮箱，这样公钥才会被github认可</span></span><br><span class="line"> ssh-keygen -t rsa -C example@126.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回车后，输入一个文件夹名字，存储新的SSH 秘钥</span></span><br><span class="line">.ssh/github</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 公钥内容 稍后加入Github 账户的 sshkey中</span></span><br><span class="line"> less ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>当然，也有可能遇到这种情况问你是否覆盖已有的密钥，你可以选择覆盖（确认没有人使用当前的SSH秘钥），或者不覆盖</p><h4 id="c-创建博客项目"><a href="#c-创建博客项目" class="headerlink" title="c.创建博客项目"></a>c.创建博客项目</h4><p>创建一个新项目，项目名称为 用户名.github.io ，比如我的Github用户名是jiaoxiangyu，则创建的项目名为<br>jiaoxiangyu.github.io<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：用户名是你的github用户名哦！千万别弄错了，不然访问不到的！</span><br></pre></td></tr></table></figure></p><h4 id="d-将ssh秘钥添加到github中"><a href="#d-将ssh秘钥添加到github中" class="headerlink" title="d.将ssh秘钥添加到github中"></a>d.将ssh秘钥添加到github中</h4><p>生成后，需要将秘钥放到github上去，登录你的github账号<br>进入秘钥设置面板:<a href="https://github.com/jiaoxiangyu/ssh" target="_blank" rel="noopener">https://github.com/jiaoxiangyu/ssh</a></p><p>在执行less ~/.ssh/id_rsa.pub你会看到一堆长密码，把这一段密码<strong>全部复制</strong>到github上</p><h4 id="e-配置Hexo，编译与部署"><a href="#e-配置Hexo，编译与部署" class="headerlink" title="e.配置Hexo，编译与部署"></a>e.配置Hexo，编译与部署</h4><p>还记得我们在_config.yml里最后一段的配置吗？</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment 这里设置了Git获</span></span><br><span class="line"><span class="comment">#这里一定要注意不要写错了，否则部署到Github上会出问题</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:jiaoxiangyu/jiaoxiangyu.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">'站点更新:<span class="template-variable">&#123;&#123;now("YYYY-MM-DD HH/mm/ss")&#125;&#125;</span>'</span></span><br></pre></td></tr></table></figure><p>这里，repo就是你创建的博客项目</p><p>最后一步，编译，上传静态代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编译</span><br><span class="line">hexo <span class="keyword">generate</span> <span class="comment">//可以简写 hexo g</span></span><br><span class="line"># 在主机的hexo目录下 执行以下命令将自动更新到Github</span><br><span class="line">hexo d <span class="comment">//可以简写 hexo d</span></span><br></pre></td></tr></table></figure><p>如果  hexo d 报错<br>ERROR Deployer not found:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure></p><p>其它命令<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">//清空你hexo/public里的内容，可以在每次修改配置文件后清除一下</span></span><br><span class="line">hexo clean <span class="meta">&amp;&amp; hexo g &amp;&amp; hexo d <span class="comment">//多条命令可以一块输入</span></span></span><br></pre></td></tr></table></figure></p><p>这就配好了，你可以用你的项目名访问你博客网站了，如：<a href="http://jaioxiangyu.github.io" target="_blank" rel="noopener">http://jaioxiangyu.github.io</a></p><p>进去是默认主题不太好看，你可以换主题<br>hexo主题网址<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>也可以看我的主题yilia是怎么配的，在我的下一篇博客笔记中</p><p>摘自：<a href="http://www.jianshu.com/p/0823e387c019" target="_blank" rel="noopener">http://www.jianshu.com/p/0823e387c019</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以前我一直用csdn博客，没有搭建自己的网站，感觉如果自己的服务器重装系统后，东西都没有了，而且csdn用着感觉还行，就不想麻烦了。前段时间我的写了一篇博客，怎么也提交不上去，而且经常出现无法提交现象，所以就觉得是时候搭建自己的博客网站了。好了不废话了，开始吧。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.lookk.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.lookk.cn/tags/hexo/"/>
    
      <category term="centOS" scheme="http://www.lookk.cn/tags/centOS/"/>
    
  </entry>
  
  <entry>
    <title>jdk和jre的区别</title>
    <link href="http://www.lookk.cn/2017/12/03/jdk%E5%92%8Cjre%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.lookk.cn/2017/12/03/jdk和jre的区别/</id>
    <published>2017-12-03T03:49:13.000Z</published>
    <updated>2017-12-06T13:47:25.153Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JVM</strong>（java virtual machineJVM）java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><p><strong>JDK</strong>（java development kit），JDK是java开发工具包，里面包含了各种类库和工具（如 javac（Java compiler）、javaw.exe(相关网络协议软件)）。当然也包括了另外一个Jre. 那么为什么要包括另外一个Jre呢？而且jdk/jre/bin同时有client和server两个文件夹下都包含一个jvm.dll。说明是有两个虚拟机的。这一点不知道大家是否注意到了呢？ 让我们看一下JDK的安装目录。<br>在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。<br>现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。</p><blockquote><p>bin :开发工具的可执行文件， 最主要的是编译器(javac.exe)； </p><p>include : java和JVM交互用的头文件；  </p><p>lib：类库  </p><p>jre : java运行环境（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）;</p><p>db ：   一个纯Java实现，开源的数据库管理系统(DBMS)java的内嵌数据库。 </p></blockquote><a id="more"></a><p>　<br>作为JDK实用程序，工具库中有七种主要程序。</p><blockquote><p>Javac：Java编译器，将Java源代码转换成字节码。<br>　　<br>Java：Java解释器，直接从类文件执行Java应用程序字节代码    </p><p>appletviewer：小程序浏览器，一种执行HTML文件上的Java小程序的Java浏览器。  　　   </p><p>Jdb：Java调试器，可以逐行执行程序，设置断点和检查变量。 </p><p>Javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件。  　　  </p><p>Javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义。</p></blockquote><p><strong>JRE</strong>（java runtime environment），是指java运行环境。光有JVM还不能完成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了。（jre里有运行.class的java.exe）</p><p>相信大家都知道jdk的bin下有各种java程序需要用到的命令，与jre的bin目录最明显的区别就是jdk下才有javac，这一点很好理解，因为 jre只是一个运行环境而已。与开发无关，正因为如此，具备开发功能的jdk自己的jre下才会同时有client性质的jvm和server性质的 jvm， 而仅仅作为运行环境的jre下只需要client性质的jvm.dll就够了。 </p><p>JDK，开发java程序用的开发包，JDK里面有java的运行环境(JRE)，包括client和server端的。需要配置环境变量。</p><p>JRE，运行java程序的环境，JVM，JRE里面只有client运行环境，安装过程中，会自动添加PATH。</p><p>试想一下如果java为了提供给大多数人使用，他们是不需要jdk做开发的，只需要jre能让java程序跑起来就可以了，那么每个客户还需要手动去设置环境变量多麻烦啊？所以安装jre的时候安装程序自动帮你把jre的java.exe添加到了系统变量中，</p><p>总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。<br>而我们通常安装的eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选中jre路径就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt;（java virtual machineJVM）java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt;（java development kit），JDK是java开发工具包，里面包含了各种类库和工具（如 javac（Java compiler）、javaw.exe(相关网络协议软件)）。当然也包括了另外一个Jre. 那么为什么要包括另外一个Jre呢？而且jdk/jre/bin同时有client和server两个文件夹下都包含一个jvm.dll。说明是有两个虚拟机的。这一点不知道大家是否注意到了呢？ 让我们看一下JDK的安装目录。&lt;br&gt;在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。&lt;br&gt;现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bin :开发工具的可执行文件， 最主要的是编译器(javac.exe)； &lt;/p&gt;
&lt;p&gt;include : java和JVM交互用的头文件；  &lt;/p&gt;
&lt;p&gt;lib：类库  &lt;/p&gt;
&lt;p&gt;jre : java运行环境（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）;&lt;/p&gt;
&lt;p&gt;db ：   一个纯Java实现，开源的数据库管理系统(DBMS)java的内嵌数据库。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="jdk" scheme="http://www.lookk.cn/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>基于JavaMail的java邮件发送</title>
    <link href="http://www.lookk.cn/2017/12/03/%E5%9F%BA%E4%BA%8EJavaMail%E7%9A%84java%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>http://www.lookk.cn/2017/12/03/基于JavaMail的java邮件发送/</id>
    <published>2017-12-03T03:46:46.000Z</published>
    <updated>2017-12-07T08:46:59.740Z</updated>
    
    <content type="html"><![CDATA[<p>电子邮件的应用非常广泛，例如在某网站注册了一个账户，自动发送一封欢迎邮件，通过邮件找回密码，自动批量发送活动信息等。但这些应用不可能和我们自己平时发邮件一样，先打开浏览器，登录邮箱，创建邮件再发送。本文将简单介绍如何通过 Java 代码来创建电子邮件，并连接邮件服务器发送邮件。</p><h2 id="1-电子邮件协议"><a href="#1-电子邮件协议" class="headerlink" title="1. 电子邮件协议"></a>1. 电子邮件协议</h2><p>电子邮件的在网络中传输和网页一样需要遵从特定的协议，常用的电子邮件协议包括 SMTP，POP3，IMAP。其中邮件的创建和发送只需要用到 SMTP协议，所以本文也只会涉及到SMTP协议。SMTP 是 Simple Mail Transfer Protocol 的简称，即简单邮件传输协议。</p><h2 id="2-JavaMail"><a href="#2-JavaMail" class="headerlink" title="2. JavaMail"></a>2. JavaMail</h2><p>我们平时通过 Java 代码打开一个 http 网页链接时，通常可以使用已经对 http 协议封装好的 HttpURLConnection 类来快速地实现。Java 官方也提供了对电子邮件协议封装的 Java 类库，就是JavaMail，但并没有包含到标准的 JDK 中，需要我们自己去官方下载，这里我从 JavaEE 官方的 Github 仓库下载。</p><p>JavaMail 下载地址: <a href="https://github.com/javaee/javamail/releases" target="_blank" rel="noopener">https://github.com/javaee/javamail/releases</a><br>下载javax.mail.jar这个jar包</p><p>特别注意:</p><blockquote><p>本测试用例用的 JavaMail 版本是 1.6.0，如果下载到其他版本的 JavaMail 运行时出现问题，请使用 JavaMail</p><p>1.6.0 版本再进行尝试。 使用 JavaMail 1.6.0 要求的 JDK 版本必须是 JDK 1.7 以上（建议使用最新版 JDK）。 </p></blockquote><a id="more"></a><h2 id="3、发送电子邮件"><a href="#3、发送电子邮件" class="headerlink" title="3、发送电子邮件"></a>3、发送电子邮件</h2><p>发送邮件首先需要有一个邮箱账号和密码，本文以网易163邮箱为例，邮箱账号必须要开启 SMTP 服务，在浏览器网页登录邮箱后一般在邮箱的“设置”选项中可以开启，并记下邮箱的 SMTP 服务器地址，如下所示（其他邮箱大同小异）:</p><p><img src="http://img.blog.csdn.net/20170828204852447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>代码实现:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.mail.Session;</span><br><span class="line"><span class="keyword">import</span> javax.mail.Transport;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JavaMail 版本: 1.6.0</span></span><br><span class="line"><span class="comment"> * JDK 版本: JDK 1.7 以上（必须）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发件人的 邮箱 和 密码（替换为自己的邮箱和密码）</span></span><br><span class="line">    <span class="comment">// PS: 某些邮箱服务器为了增加邮箱本身密码的安全性，给 SMTP 客户端设置了独立密码（有的邮箱称为“授权码”）, </span></span><br><span class="line">    <span class="comment">//     对于开启了独立密码的邮箱, 这里的邮箱密码必需使用这个独立密码（授权码）。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> myEmailAccount = <span class="string">"xxxxxxxxx@163.com"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> myEmailPassword = <span class="string">"xxxxxxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般(只是一般, 绝非绝对)格式为: smtp.xxx.com</span></span><br><span class="line">    <span class="comment">// 网易163邮箱的 SMTP 服务器地址为: smtp.163.com</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> myEmailSMTPHost = <span class="string">"smtp.163.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收件人邮箱（替换为自己知道的有效邮箱）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> receiveMailAccount = <span class="string">"xxxxxxxxx@qq.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建参数配置, 用于连接邮件服务器的参数配置</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> <span class="type">Properties</span>();                    <span class="comment">// 参数配置</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);   <span class="comment">// 使用的协议（JavaMail规范要求）</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.host"</span>, myEmailSMTPHost);   <span class="comment">// 发件人的邮箱的 SMTP 服务器地址</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);            <span class="comment">// 需要请求认证</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// PS: 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启),</span></span><br><span class="line">        <span class="comment">//     如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误,</span></span><br><span class="line">        <span class="comment">//     打开下面 /* ... */ 之间的注释代码, 开启 SSL 安全连接。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接,</span></span><br><span class="line"><span class="comment">        //                  需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助,</span></span><br><span class="line"><span class="comment">        //                  QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看)</span></span><br><span class="line"><span class="comment">        final String smtpPort = "465";</span></span><br><span class="line"><span class="comment">        props.setProperty("mail.smtp.port", smtpPort);</span></span><br><span class="line"><span class="comment">        props.setProperty("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");</span></span><br><span class="line"><span class="comment">        props.setProperty("mail.smtp.socketFactory.fallback", "false");</span></span><br><span class="line"><span class="comment">        props.setProperty("mail.smtp.socketFactory.port", smtpPort);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 根据配置创建会话对象, 用于和邮件服务器交互</span></span><br><span class="line">        Session session = Session.getDefaultInstance(props);</span><br><span class="line">        session.setDebug(<span class="literal">true</span>);                                 <span class="comment">// 设置为debug模式, 可以查看详细的发送 log</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建一封邮件</span></span><br><span class="line">        MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 根据 Session 获取邮件传输对象</span></span><br><span class="line">        Transport transport = session.getTransport();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">//    PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log,</span></span><br><span class="line">        <span class="comment">//           仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误</span></span><br><span class="line">        <span class="comment">//           类型到对应邮件服务器的帮助网站上查看具体失败原因。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//    PS_02: 连接失败的原因通常为以下几点, 仔细检查代码:</span></span><br><span class="line">        <span class="comment">//           (1) 邮箱没有开启 SMTP 服务;</span></span><br><span class="line">        <span class="comment">//           (2) 邮箱密码错误, 例如某些邮箱开启了独立密码;</span></span><br><span class="line">        <span class="comment">//           (3) 邮箱服务器要求必须要使用 SSL 安全连接;</span></span><br><span class="line">        <span class="comment">//           (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务;</span></span><br><span class="line">        <span class="comment">//           (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//    PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。</span></span><br><span class="line">        transport.connect(myEmailAccount, myEmailPassword);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span></span><br><span class="line">        transport.sendMessage(message, message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 关闭连接</span></span><br><span class="line">        transport.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一封只包含文本的简单邮件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param session 和服务器交互的会话</span></span><br><span class="line"><span class="comment">     * @param sendMail 发件人邮箱</span></span><br><span class="line"><span class="comment">     * @param receiveMail 收件人邮箱</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MimeMessage createMimeMessage(Session session, <span class="keyword">String</span> sendMail, <span class="keyword">String</span> receiveMail) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一封邮件</span></span><br><span class="line">        MimeMessage message = <span class="keyword">new</span> <span class="type">MimeMessage</span>(session);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. From: 发件人（昵称有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改昵称）</span></span><br><span class="line">        message.setFrom(<span class="keyword">new</span> <span class="type">InternetAddress</span>(sendMail, <span class="string">"某宝网"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. To: 收件人（可以增加多个收件人、抄送、密送）</span></span><br><span class="line">        message.setRecipient(MimeMessage.RecipientType.TO, <span class="keyword">new</span> <span class="type">InternetAddress</span>(receiveMail, <span class="string">"XX用户"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. Subject: 邮件主题（标题有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改标题）</span></span><br><span class="line">        message.setSubject(<span class="string">"打折钜惠"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. Content: 邮件正文（可以使用html标签）（内容有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改发送内容）</span></span><br><span class="line">        message.setContent(<span class="string">"XX用户你好, 今天全场5折, 快来抢购, 错过今天再等一年。。。"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 设置发件时间</span></span><br><span class="line">        message.setSentDate(<span class="keyword">new</span> <span class="type">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 保存设置</span></span><br><span class="line">        message.saveChanges();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送后查看收件人的收件箱，看是否成功。</p><p>摘自：<a href="http://blog.csdn.net/xietansheng/article/details/51673073" target="_blank" rel="noopener">http://blog.csdn.net/xietansheng/article/details/51673073</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电子邮件的应用非常广泛，例如在某网站注册了一个账户，自动发送一封欢迎邮件，通过邮件找回密码，自动批量发送活动信息等。但这些应用不可能和我们自己平时发邮件一样，先打开浏览器，登录邮箱，创建邮件再发送。本文将简单介绍如何通过 Java 代码来创建电子邮件，并连接邮件服务器发送邮件。&lt;/p&gt;
&lt;h2 id=&quot;1-电子邮件协议&quot;&gt;&lt;a href=&quot;#1-电子邮件协议&quot; class=&quot;headerlink&quot; title=&quot;1. 电子邮件协议&quot;&gt;&lt;/a&gt;1. 电子邮件协议&lt;/h2&gt;&lt;p&gt;电子邮件的在网络中传输和网页一样需要遵从特定的协议，常用的电子邮件协议包括 SMTP，POP3，IMAP。其中邮件的创建和发送只需要用到 SMTP协议，所以本文也只会涉及到SMTP协议。SMTP 是 Simple Mail Transfer Protocol 的简称，即简单邮件传输协议。&lt;/p&gt;
&lt;h2 id=&quot;2-JavaMail&quot;&gt;&lt;a href=&quot;#2-JavaMail&quot; class=&quot;headerlink&quot; title=&quot;2. JavaMail&quot;&gt;&lt;/a&gt;2. JavaMail&lt;/h2&gt;&lt;p&gt;我们平时通过 Java 代码打开一个 http 网页链接时，通常可以使用已经对 http 协议封装好的 HttpURLConnection 类来快速地实现。Java 官方也提供了对电子邮件协议封装的 Java 类库，就是JavaMail，但并没有包含到标准的 JDK 中，需要我们自己去官方下载，这里我从 JavaEE 官方的 Github 仓库下载。&lt;/p&gt;
&lt;p&gt;JavaMail 下载地址: &lt;a href=&quot;https://github.com/javaee/javamail/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/javaee/javamail/releases&lt;/a&gt;&lt;br&gt;下载javax.mail.jar这个jar包&lt;/p&gt;
&lt;p&gt;特别注意:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本测试用例用的 JavaMail 版本是 1.6.0，如果下载到其他版本的 JavaMail 运行时出现问题，请使用 JavaMail&lt;/p&gt;
&lt;p&gt;1.6.0 版本再进行尝试。 使用 JavaMail 1.6.0 要求的 JDK 版本必须是 JDK 1.7 以上（建议使用最新版 JDK）。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="JavaMail" scheme="http://www.lookk.cn/tags/JavaMail/"/>
    
  </entry>
  
  <entry>
    <title>Java中堆和栈的区别</title>
    <link href="http://www.lookk.cn/2017/12/03/Java%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.lookk.cn/2017/12/03/Java中堆和栈的区别/</id>
    <published>2017-12-03T03:45:17.000Z</published>
    <updated>2017-12-07T08:42:33.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。   </p><p>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。  </p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆内存用来存放由new创建的对象和数组。   </p><p>在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。   </p><p> 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。   </p><p>引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   </p><p><strong>java中变量在内存中的分配</strong></p><p>1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭</p><p>2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</p><p>3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</p><a id="more"></a><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>各司其职</strong></p><p>最主要的区别就是栈内存用来存储局部变量和方法调用。<br>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p><p><strong>独有还是共享</strong></p><p>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。<br>而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p><p><strong>异常错误</strong></p><p>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p><p><strong>空间大小</strong></p><p>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。<br>你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。</p><p>这就是Java中堆和栈的区别。理解好这个问题的话，可以对你解决开发中的问题，分析堆内存和栈内存使用，甚至性能调优都有帮助。</p><p><strong>查看默认值(Updated)</strong></p><p>查看堆的默认值，使用下面的代码，其中InitialHeapSize为最开始的堆的大小，MaxHeapSize为堆的最大值</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">$ java -XX:+PrintFlagsFinal -version | grep HeapSize</span></span><br><span class="line"><span class="xml">    uintx ErgoHeapSizeLimit                         = 0                                   </span><span class="template-variable">&#123;product&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    uintx HeapSizePerGCThread                       = 87241520                            </span><span class="template-variable">&#123;product&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    uintx InitialHeapSize                          := 134217728                           </span><span class="template-variable">&#123;product&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    uintx LargePageHeapSizeThreshold                = 134217728                           </span><span class="template-variable">&#123;product&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    uintx MaxHeapSize                              := 2147483648                          </span><span class="template-variable">&#123;product&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>查看栈的默认值,其中ThreadStackSize为栈内存的大小。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">$ java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</span></span><br><span class="line"><span class="xml">     intx CompilerThreadStackSize                   = 0                                   </span><span class="template-variable">&#123;pd product&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">     intx ThreadStackSize                           = 1024                                </span><span class="template-variable">&#123;pd product&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">     intx VMThreadStackSize                         = 1024                                </span><span class="template-variable">&#123;pd product&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h2 id="附：java的内存机制"><a href="#附：java的内存机制" class="headerlink" title="附：java的内存机制"></a>附：java的内存机制</h2><p>Java 把内存划分成两种：一种是栈内存，另一种是堆内存。</p><p>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。</p><p>　　堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。</p><p>　　这也是 Java 比较占内存的原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！</p><p><strong>摘自：</strong><br><a href="http://www.cnblogs.com/perfy/p/3820594.html" target="_blank" rel="noopener">http://www.cnblogs.com/perfy/p/3820594.html</a><br><a href="http://www.cnblogs.com/androidhome/p/5182496.html" target="_blank" rel="noopener">http://www.cnblogs.com/androidhome/p/5182496.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;p&gt;在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。   &lt;/p&gt;
&lt;p&gt;当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。  &lt;/p&gt;
&lt;h2 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h2&gt;&lt;p&gt;堆内存用来存放由new创建的对象和数组。   &lt;/p&gt;
&lt;p&gt;在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。   &lt;/p&gt;
&lt;p&gt; 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。   &lt;/p&gt;
&lt;p&gt;引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java中变量在内存中的分配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭&lt;/p&gt;
&lt;p&gt;2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存&lt;/p&gt;
&lt;p&gt;3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="堆栈" scheme="http://www.lookk.cn/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Java ClassLoader原理</title>
    <link href="http://www.lookk.cn/2017/12/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java-ClassLoader%E5%8E%9F%E7%90%86/"/>
    <id>http://www.lookk.cn/2017/12/03/深入分析Java-ClassLoader原理/</id>
    <published>2017-12-03T03:43:48.000Z</published>
    <updated>2017-12-07T08:47:20.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是ClassLoader"><a href="#一、什么是ClassLoader" class="headerlink" title="一、什么是ClassLoader?"></a>一、什么是ClassLoader?</h2><p>大家都知道，当我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。</p><h2 id="二、Java默认提供的三个ClassLoader"><a href="#二、Java默认提供的三个ClassLoader" class="headerlink" title="二、Java默认提供的三个ClassLoader"></a>二、Java默认提供的三个ClassLoader</h2><p><strong>1、BootStrap ClassLoader</strong>：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();  </span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; urls.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;  </span><br><span class="line">    System.out.println(urls[i].toExternalForm());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下内容是上述程序从本机JDK环境所获得的结果：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">resources</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">sunrsasign</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">jsse</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">jce</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">charsets</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">jfr</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/<span class="symbol">C:</span>/Program%<span class="number">20</span>Files/Java/jdk1.<span class="number">8.0_73</span>/jre/classes</span><br></pre></td></tr></table></figure></p><p>其实上述结果也是通过查找sun.boot.class.path这个系统属性所得知的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">System</span><span class="selector-class">.getProperty</span>("<span class="selector-tag">sun</span><span class="selector-class">.boot</span><span class="selector-class">.class</span><span class="selector-class">.path</span>"));</span><br></pre></td></tr></table></figure></p><p><strong>2、Extension ClassLoader</strong>：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。还可以加载<code>-D java.ext.dirs</code>选项指定的目录。 </p><p><strong>3、App ClassLoader</strong>：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</p><p>注意： 除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</p><a id="more"></a><p>为了更好的理解，我们可以查看源码。 </p><p><strong>看sun.misc.Launcher,它是一个java虚拟机的入口应用。</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="type">Launcher</span> launcher = <span class="keyword">new</span> <span class="type">Launcher</span>();</span><br><span class="line">    <span class="keyword">private</span> static <span class="type">String</span> bootClassPath =</span><br><span class="line">        <span class="type">System</span>.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line">    public static <span class="type">Launcher</span> getLauncher() &#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ClassLoader</span> loader;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Launcher</span>() &#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        <span class="type">ClassLoader</span> extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = <span class="type">ExtClassLoader</span>.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(</span><br><span class="line">                <span class="string">"Could not create extension class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = <span class="type">AppClassLoader</span>.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InternalError</span>(</span><br><span class="line">                <span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解</span></span><br><span class="line">        <span class="type">Thread</span>.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="type">ClassLoader</span> getClassLoader() &#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>源码有精简，我们可以得到相关的信息。 </p><ol><li>Launcher初始化了ExtClassLoader和AppClassLoader。 </li><li>Launcher中并没有看见BootstrapClassLoader，但通过<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。以上已测试过，可以看到，全是JRE目录下的jar包或者是class文件。</li></ol><p><strong>ExtClassLoader源码</strong></p><p>如果你有足够的好奇心，你应该会对它的源码感兴趣</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> ExtClassLoader <span class="keyword">extends</span> URLClassLoader &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           ClassLoader.registerAsParallelCapable();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * create an ExtClassLoader. The ExtClassLoader is created</span></span><br><span class="line"><span class="comment">        * within a context that limits which files it can read</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader getExtClassLoader() <span class="keyword">throws</span> IOException</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">File</span>[] dirs = getExtDirs();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Prior implementations of this doPrivileged() block supplied</span></span><br><span class="line">               <span class="comment">// aa synthesized ACC via a call to the private method</span></span><br><span class="line">               <span class="comment">// ExtClassLoader.getContext().</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                   <span class="keyword">new</span> PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                       <span class="keyword">public</span> ExtClassLoader run() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                           <span class="keyword">int</span> len = dirs.length;</span><br><span class="line">                           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                               MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">new</span> ExtClassLoader(dirs);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">File</span>[] getExtDirs() &#123;</span><br><span class="line">           String s = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">           <span class="keyword">File</span>[] dirs;</span><br><span class="line">           <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">               StringTokenizer st =</span><br><span class="line">                   <span class="keyword">new</span> StringTokenizer(s, <span class="keyword">File</span>.pathSeparator);</span><br><span class="line">               <span class="keyword">int</span> <span class="keyword">count</span> = st.countTokens();</span><br><span class="line">               dirs = <span class="keyword">new</span> <span class="keyword">File</span>[<span class="keyword">count</span>];</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">                   dirs[i] = <span class="keyword">new</span> <span class="keyword">File</span>(st.nextToken());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               dirs = <span class="keyword">new</span> <span class="keyword">File</span>[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> dirs;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们先前的内容有说过，可以指定<code>-D java.ext.dirs</code>参数来添加和改变ExtClassLoader的加载路径。这里我们通过可以编写测试代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">System</span><span class="selector-class">.getProperty</span>("<span class="selector-tag">java</span><span class="selector-class">.ext</span><span class="selector-class">.dirs</span>"));</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">C:</span>\Program Files\Java\jdk1.<span class="number">8.0_73</span>\jre\<span class="class"><span class="keyword">lib</span>\<span class="title">ext</span>;</span><span class="symbol">C:</span>\Windows\Sun\Java\<span class="class"><span class="keyword">lib</span>\<span class="title">ext</span></span></span><br></pre></td></tr></table></figure><p><strong>AppClassLoader源码</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">    * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   static <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       public static <span class="type">ClassLoader</span> getAppClassLoader(<span class="keyword">final</span> <span class="type">ClassLoader</span> extcl)</span><br><span class="line">           <span class="keyword">throws</span> <span class="type">IOException</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">String</span> s = <span class="type">System</span>.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">           <span class="keyword">final</span> <span class="type">File</span>[] path = (s == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="type">File</span>[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="type">AccessController</span>.doPrivileged(</span><br><span class="line">               <span class="keyword">new</span> <span class="type">PrivilegedAction</span>&lt;<span class="type">AppClassLoader</span>&gt;() &#123;</span><br><span class="line">                   public <span class="type">AppClassLoader</span> run() &#123;</span><br><span class="line">                   <span class="type">URL</span>[] urls =</span><br><span class="line">                       (s == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="type">URL</span>[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">AppClassLoader</span>(urls, extcl);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到AppClassLoader加载的就是java.class.path下的路径。我们同样打印它的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="selector-tag">System</span><span class="selector-class">.getProperty</span>("<span class="selector-tag">java</span><span class="selector-class">.class</span><span class="selector-class">.path</span>"));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:<span class="symbol">\w</span>orkspace<span class="symbol">\j</span>avatest<span class="symbol">\t</span>arget<span class="symbol">\c</span>lasses</span><br></pre></td></tr></table></figure><p>这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。</p><h2 id="三、ClassLoader加载类的原理"><a href="#三、ClassLoader加载类的原理" class="headerlink" title="三、ClassLoader加载类的原理"></a>三、ClassLoader加载类的原理</h2><p> <strong>1、原理介绍</strong></p><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p><p><strong>2、为什么要使用双亲委托这种模型呢？</strong></p><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p><p><strong>3、 但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？</strong></p><p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。</p><p><strong>4、ClassLoader的体系架构：</strong></p><p><img src="http://img.blog.csdn.net/20170905184327025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>验证ClassLoader加载类的原理：</strong></p><p><strong>测试1</strong>：打印ClassLoader类的层次结构，请看下面这段代码：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = ClassLoaderTest.<span class="keyword">class</span>.getClassLoader();    <span class="comment">//获得加载ClassLoaderTest.class这个类的类加载器  </span></span><br><span class="line"><span class="keyword">while</span>(loader != <span class="literal">null</span>) &#123;  </span><br><span class="line">    System.<span class="keyword">out</span>.println(loader);  </span><br><span class="line">    loader = loader.getParent();    <span class="comment">//获得父类加载器的引用  </span></span><br><span class="line">&#125;  </span><br><span class="line">System.<span class="keyword">out</span>.println(loader);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$AppClassLoader</span>@<span class="number">4</span>e0e2f2a</span><br><span class="line">sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$ExtClassLoader</span>@<span class="number">2</span>a139a55</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>第一行结果说明：ClassLoaderTest的类加载器是AppClassLoader。<br>第二行结果说明：AppClassLoader的类加器是ExtClassLoader，即parent=ExtClassLoader。<br>第三行结果说明：ExtClassLoader的类加器是Bootstrap ClassLoader，因为Bootstrap ClassLoader不是一个普通的Java类，所以ExtClassLoader的parent=null，所以第三行的打印结果为null就是这个原因。</p><p> 注意：在双亲委托模型中，AppClassLoader的类加器是ExtClassLoader，但从源码可以看出AppClassLoader 和 ExtClassLoader 都扩展于 URLClassLoader加载器.说明AppClassLoader而非继承ExtClassLoader.</p><p><strong>测试2</strong>：将ClassLoaderTest.class打包成ClassLoaderTest.jar，放到Extension ClassLoader的加载目录下（JAVA_HOME/jre/lib/ext），然后重新运行这个程序，得到的结果会是什么样呢？</p><p>打印结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$ExtClassLoader</span>@<span class="number">4</span>e25154f</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>打印结果分析：</p><p>为什么第一行的结果是ExtClassLoader呢？<br>      因为ClassLoader的委托模型机制，当我们要用ClassLoaderTest.class这个类的时候，AppClassLoader在试图加载之前，先委托给Bootstrcp ClassLoader，Bootstracp ClassLoader发现自己没找到，它就告诉ExtClassLoader，兄弟，我这里没有这个类，你去加载看看，然后Extension ClassLoader拿着这个类去它指定的类路径（JAVA_HOME/jre/lib/ext）试图加载，唉，它发现在ClassLoaderTest.jar这样一个文件中包含ClassLoaderTest.class这样的一个文件，然后它把找到的这个类加载到内存当中，并生成这个类的Class实例对象，最后把这个实例返回。所以ClassLoaderTest.class的类加载器是ExtClassLoader。</p><p>第二行的结果为null，是因为ExtClassLoader的父类加载器是Bootstrap ClassLoader。</p><h2 id="四、定义自已的ClassLoader"><a href="#四、定义自已的ClassLoader" class="headerlink" title="四、定义自已的ClassLoader"></a>四、定义自已的ClassLoader</h2><p>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？</p><p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。<br>定义自已的类加载器分为两步：<br>1、继承java.lang.ClassLoader<br>2、重写父类的findClass方法</p><p>读者可能在这里有疑问，父类有那么多方法，为什么偏偏只重写findClass方法？</p><p>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。下图是API中ClassLoader的loadClass方法：<br><img src="http://img.blog.csdn.net/20170907203351843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>示例：自定义一个NetworkClassLoader，用于加载网络上的class文件</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;  </span><br><span class="line"><span class="keyword">import</span> java.net.URL;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 加载网络class的ClassLoader </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">ClassLoader</span></span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> rootUrl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> NetworkClassLoader(<span class="keyword">String</span> rootUrl) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.rootUrl = rootUrl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected Class&lt;?&gt; findClass(<span class="keyword">String</span> name) throws ClassNotFoundException &#123;  </span><br><span class="line">        Class clazz = <span class="literal">null</span>;<span class="comment">//this.findLoadedClass(name); // 父类已加载     </span></span><br><span class="line">        <span class="comment">//if (clazz == null) &#123;  //检查该类是否已被加载过  </span></span><br><span class="line">            byte[] classData = getClassData(name);  <span class="comment">//根据类的二进制名称,获得该class文件的字节码数组  </span></span><br><span class="line">            <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClassNotFoundException</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">            clazz = defineClass(name, classData, <span class="number">0</span>, classData.length);  <span class="comment">//将class的字节码数组转换成Class类的实例  </span></span><br><span class="line">        <span class="comment">//&#125;   </span></span><br><span class="line">        <span class="keyword">return</span> clazz;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> byte[] getClassData(<span class="keyword">String</span> name) &#123;  </span><br><span class="line">        InputStream is = <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">String</span> path = classNameToPath(name);  </span><br><span class="line">            URL url = <span class="keyword">new</span> <span class="type">URL</span>(path);  </span><br><span class="line">            byte[] buff = <span class="keyword">new</span> <span class="type">byte</span>[<span class="number">1024</span>*<span class="number">4</span>];  </span><br><span class="line">            int len = <span class="number">-1</span>;  </span><br><span class="line">            is = url.openStream();  </span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> <span class="type">ByteArrayOutputStream</span>();  </span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buff)) != <span class="number">-1</span>) &#123;  </span><br><span class="line">                baos.write(buff,<span class="number">0</span>,len);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">try</span> &#123;  </span><br><span class="line">                  is.close();  </span><br><span class="line">               &#125; <span class="keyword">catch</span>(IOException e) &#123;  </span><br><span class="line">                  e.printStackTrace();  </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> classNameToPath(<span class="keyword">String</span> name) &#123;  </span><br><span class="line">        <span class="keyword">return</span> rootUrl + <span class="string">"/"</span> + name.replace(<span class="string">"."</span>, <span class="string">"/"</span>) + <span class="string">".class"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">/*ClassLoader loader = ClassLoaderTest.class.getClassLoader();  //获得ClassLoaderTest这个类的类加载器 </span></span><br><span class="line"><span class="comment">            while(loader != null) &#123; </span></span><br><span class="line"><span class="comment">                System.out.println(loader); </span></span><br><span class="line"><span class="comment">                loader = loader.getParent();    //获得父加载器的引用 </span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">            System.out.println(loader);*/</span>  </span><br><span class="line">              </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">String</span> rootUrl = <span class="string">"http://localhost:8080/httpweb/classes"</span>;  </span><br><span class="line">            NetworkClassLoader networkClassLoader = <span class="keyword">new</span> <span class="type">NetworkClassLoader</span>(rootUrl);  </span><br><span class="line">            <span class="keyword">String</span> classname = <span class="string">"org.classloader.simple.NetClassLoaderTest"</span>;  </span><br><span class="line">            Class clazz = networkClassLoader.loadClass(classname);  </span><br><span class="line">            System.out.println(clazz.getClassLoader());  </span><br><span class="line">              </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：<br><img src="http://img.blog.csdn.net/20170907211603732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzIzMzcxMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>摘自：<br><a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener"> 深入分析Java ClassLoader原理</a></p><p><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">一看你就懂，超详细java中的ClassLoader详解</a></p><p><a href="http://blog.csdn.net/irelandken/article/details/7046689" target="_blank" rel="noopener">分析AppClassLoader,ExtClassLoader 和URLClassLoader 的关系</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是ClassLoader&quot;&gt;&lt;a href=&quot;#一、什么是ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;一、什么是ClassLoader?&quot;&gt;&lt;/a&gt;一、什么是ClassLoader?&lt;/h2&gt;&lt;p&gt;大家都知道，当我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。&lt;/p&gt;
&lt;h2 id=&quot;二、Java默认提供的三个ClassLoader&quot;&gt;&lt;a href=&quot;#二、Java默认提供的三个ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;二、Java默认提供的三个ClassLoader&quot;&gt;&lt;/a&gt;二、Java默认提供的三个ClassLoader&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、BootStrap ClassLoader&lt;/strong&gt;：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：&lt;/p&gt;
&lt;figure class=&quot;highlight matlab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (int &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt; &amp;lt; urls.&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;++) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(urls[i].toExternalForm());  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下内容是上述程序从本机JDK环境所获得的结果：&lt;br&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;resources&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;rt&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;sunrsasign&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;jsse&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;jce&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;charsets&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;jfr&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;file:&lt;/span&gt;/&lt;span class=&quot;symbol&quot;&gt;C:&lt;/span&gt;/Program%&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;Files/Java/jdk1.&lt;span class=&quot;number&quot;&gt;8.0_73&lt;/span&gt;/jre/classes&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实上述结果也是通过查找sun.boot.class.path这个系统属性所得知的。&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.out&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.println&lt;/span&gt;(&lt;span class=&quot;selector-tag&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getProperty&lt;/span&gt;(&quot;&lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.boot&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.class&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.path&lt;/span&gt;&quot;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Extension ClassLoader&lt;/strong&gt;：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。还可以加载&lt;code&gt;-D java.ext.dirs&lt;/code&gt;选项指定的目录。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、App ClassLoader&lt;/strong&gt;：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。&lt;/p&gt;
&lt;p&gt;注意： 除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.lookk.cn/tags/JVM/"/>
    
      <category term="ClassLoader原理" scheme="http://www.lookk.cn/tags/ClassLoader%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="http://www.lookk.cn/2017/12/03/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.lookk.cn/2017/12/03/Java垃圾回收机制/</id>
    <published>2017-12-03T03:42:28.000Z</published>
    <updated>2017-12-07T08:42:43.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-垃圾回收的意义"><a href="#1-垃圾回收的意义" class="headerlink" title="1. 垃圾回收的意义"></a>1. 垃圾回收的意义</h2><p>　　在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。<br>　　<br>　　垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收算法的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</p><h2 id="2-垃圾收集的算法分析"><a href="#2-垃圾收集的算法分析" class="headerlink" title="2. 垃圾收集的算法分析"></a>2. 垃圾收集的算法分析</h2><p>　　Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。<br>　　<br>　　大多数垃圾回收算法使用了根集(root set)这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。下面介绍几个常用的算法。<br>　　<br><strong>2.1. 引用计数法(Reference Counting Collector)</strong> 　　<br>　　引用计数法是唯一没有使用根集的垃圾回收的法，该算法使用引用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。<br>　　基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。但引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域生，计数器减1。<br>　　<br><strong>2.2. tracing算法(Tracing Collector)</strong> 　<br>　　tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.<br>　　<br><strong>2.3. compacting算法(Compacting Collector)</strong> 　<br>　　为了解决堆碎片问题，基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。<br>　　<br><strong>2.4. copying算法(Coping Collector)</strong><br>　　该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。<br>　　一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。<br>　　<br><strong>2.5. generation算法(Generational Collector)</strong><br>　　stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。<br>　　<br><strong>2.6. adaptive算法(Adaptive Collector)</strong><br>　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p><a id="more"></a><h2 id="3-System-gc-方法"><a href="#3-System-gc-方法" class="headerlink" title="3. System.gc()方法"></a>3. System.gc()方法</h2><p><strong>命令行参数透视垃圾收集器的运行</strong><br>使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java -verbosegc classfile</span></span><br></pre></td></tr></table></figure><p>可以看个例子：<br>　　<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestGC</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">　　    <span class="keyword">new</span> TestGC();  </span><br><span class="line">　　    System.gc();  </span><br><span class="line">　　    System.runFinalization();  </span><br><span class="line">　　 &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为不可达，程序编译后，执行命令： java -verbosegc TestGC 后结果为：<br>　　[Full GC 168K-&gt;97K(1984K)， 0.0253873 secs]<br>　　机器的环境为，Windows 2000 + JDK1.3.1，箭头前后的数据168K和97K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有168K-97K=71K的对象容量被回收，括号内的数据1984K为堆内存的总容量，收集所需要的时间是0.0253873秒（这个时间在每次执行的时候会有所不同）。</p><blockquote><p>需要注意的是，调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p></blockquote><h2 id="4-finalize-方法"><a href="#4-finalize-方法" class="headerlink" title="4. finalize()方法"></a>4. finalize()方法</h2><p>在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。它的原型为：<br>　　protected void finalize() throws Throwable<br>　　在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。<br>　　之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p><p>特殊的区域例如：1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。<br>      换言之，finalize()的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。因为在JAVA中并没有提够像“析构”函数或者类似概念的函数，要做一些类似清理工作的时候，必须自己动手创建一个执行清理工作的普通方法，也就是override Object这个类中的finalize()方法。例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远都不会被清理。如果在finalize()加入某一种擦除功能，当GC工作时，finalize()得到了调用，图像就会被擦除。要是GC没有发生，那么这个图像就会被一直保存下来。<br>一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用finalize()方法进行一些必要的清理工作。只有到下一次再进行垃圾回收动作的时候，才会真正释放这个对象所占用的内存空间。<br>　　在普通的清除工作中，为清除一个对象，那个对象的用户必须在希望进行清除的地点调用一个清除方法。这与C++”析构函数”的概念稍有抵触。在C++中，所有对象都会破坏（清除）。或者换句话说，所有对象都”应该”破坏。若将C++对象创建成一个本地对象，比如在堆栈中创建（在Java中是不可能的，Java都在堆中），那么清除或破坏工作就会在”结束花括号”所代表的、创建这个对象的作用域的末尾进行。若对象是用new创建的（类似于Java），那么当程序员调用C++的 delete命令时（Java没有这个命令），就会调用相应的析构函数。若程序员忘记了，那么永远不会调用析构函数，我们最终得到的将是一个内存”漏洞”，另外还包括对象的其他部分永远不会得到清除。<br>　　相反，Java不允许我们创建本地（局部）对象–无论如何都要使用new。但在Java中，没有”delete”命令来释放对象，因为垃圾回收器会帮助我们自动释放存储空间。所以如果站在比较简化的立场，我们可以说正是由于存在垃圾回收机制，所以Java没有析构函数。然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对析构函数的需要，或者说不能消除对析构函数代表的那种机制的需要（原因见下一段。另外finalize()函数是在垃圾回收器准备释放对象占用的存储空间的时候被调用的，绝对不能直接调用finalize()，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用Java中的一个方法。它等价于C++的析构函数，只是没后者方便。<br>      在C++中所有的对象运用delete()一定会被销毁，而JAVA里的对象并非总会被垃圾回收器回收。In another word, 1 对象可能不被垃圾回收，2 垃圾回收并不等于“析构”，3 垃圾回收只与内存有关。也就是说，并不是如果一个对象不再被使用，是不是要在finalize()中释放这个对象中含有的其它对象呢？不是的。因为无论对象是如何创建的，垃圾回收器都会负责释放那些对象占有的内存。</p><h2 id="5-触发主GC（Garbage-Collector）的条件"><a href="#5-触发主GC（Garbage-Collector）的条件" class="headerlink" title="5. 触发主GC（Garbage Collector）的条件"></a>5. 触发主GC（Garbage Collector）的条件</h2><p>　　JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。更值得关注的是主GC的触发条件,因为它对系统影响很明显。总的来说,有两个条件会触发主GC:</p><p>　　1)当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。</p><p>　　2)Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</p><p>　　由于是否进行主GC由JVM根据系统环境决定,而系统环境在不断的变化当中,所以主GC的运行具有不确定性,无法预计它何时必然出现,但可以确定的是对一个长期运行的应用来说,其主GC是反复进行的。</p><h2 id="6-减少GC开销的措施"><a href="#6-减少GC开销的措施" class="headerlink" title="6. 减少GC开销的措施"></a>6. 减少GC开销的措施</h2><p>　　根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:</p><p>　　<strong>(1)不要显式调用System.gc()</strong></p><p>　　此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</p><p>　　<strong>(2)尽量减少临时对象的使用</strong></p><p>　　临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</p><p>　　<strong>(3)对象不用时最好显式置为Null</strong></p><p>　　一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</p><p>　　<strong>(4)尽量使用StringBuffer,而不用String来累加字符串</strong></p><p>　　由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p><p>　　<strong>(5)能用基本类型如Int,Long,就不用Integer,Long对象</strong></p><p>　　基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</p><p>　　<strong>(6)尽量少用静态对象变量</strong></p><p>　　静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</p><p>　　<strong>(7)分散对象创建或删除的时间</strong></p><p>　　集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</p><h2 id="7-关于垃圾回收的几点补充"><a href="#7-关于垃圾回收的几点补充" class="headerlink" title="7. 关于垃圾回收的几点补充"></a>7. 关于垃圾回收的几点补充</h2><p>　　经过上述的说明，可以发现垃圾回收有以下的几个特点：<br>　　（1）垃圾收集发生的不可预知性：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。<br>　　<br>　　（2）垃圾收集的精确性：主要包括2 个方面：（a）垃圾收集器能够精确标记活着的对象；（b）垃圾收集器能够精确地定位对象之间的引用关系。前者是完全地回收所有废弃对象的前提，否则就可能造成内存泄漏。而后者则是实现归并和复制等算法的必要条件。所有不可达对象都能够可靠地得到回收，所有对象都能够重新分配，允许对象的复制和对象内存的缩并，这样就有效地防止内存的支离破碎。<br>　　<br>　　（3）现在有许多种不同的垃圾收集器，每种有其算法且其表现各异，既有当垃圾收集开始时就停止应用程序的运行，又有当垃圾收集开始时也允许应用程序的线程运行，还有在同一时间垃圾收集多线程运行。<br>　　<br>　　（4）垃圾收集的实现和具体的JVM 以及JVM的内存模型有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集。现在，HotSpot 系列JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。<br>　　<br>　　（5）随着技术的发展，现代垃圾收集技术提供许多可选的垃圾收集器，而且在配置每种收集器的时候又可以设置不同的参数，这就使得根据不同的应用环境获得最优的应用性能成为可能。<br>　　针对以上特点，我们在使用的时候要注意：<br>　　（1）不要试图去假定垃圾收集发生的时间，这一切都是未知的。比如，方法中的一个临时对象在方法调用完毕后就变成了无用对象，这个时候它的内存就可以被释放。<br>　　（2）Java中提供了一些和垃圾收集打交道的类，而且提供了一种强行执行垃圾收集的方法–调用System.gc()，但这同样是个不确定的方法。Java 中并不保证每次调用该方法就一定能够启动垃圾收集，它只不过会向JVM发出这样一个申请，到底是否真正执行垃圾收集，一切都是个未知数。<br>　　（3）挑选适合自己的垃圾收集器。一般来说，如果系统没有特殊和苛刻的性能要求，可以采用JVM的缺省选项。否则可以考虑使用有针对性的垃圾收集器，比如增量收集器就比较适合实时性要求较高的系统之中。系统具有较高的配置，有比较多的闲置资源，可以考虑使用并行标记/清除收集器。<br>　　（4）关键的也是难把握的问题是内存泄漏。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。<br>　　（5）尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的对象是否被监听，如果有，则要去掉监听器，然后再赋空值。<br>　<br>摘自：<br><a href="http://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">Java垃圾回收机制</a><br><a href="http://blog.sina.com.cn/s/blog_5ef35aa00100ky9o.html" target="_blank" rel="noopener">java垃圾回收机制——finallize()</a><br><a href="http://www.cnblogs.com/shudonghe/p/3457990.html" target="_blank" rel="noopener">Java Garbage Collection基础详解——Java 垃圾回收机制技术详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-垃圾回收的意义&quot;&gt;&lt;a href=&quot;#1-垃圾回收的意义&quot; class=&quot;headerlink&quot; title=&quot;1. 垃圾回收的意义&quot;&gt;&lt;/a&gt;1. 垃圾回收的意义&lt;/h2&gt;&lt;p&gt;　　在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。&lt;br&gt;　　&lt;br&gt;　　垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收算法的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。&lt;/p&gt;
&lt;h2 id=&quot;2-垃圾收集的算法分析&quot;&gt;&lt;a href=&quot;#2-垃圾收集的算法分析&quot; class=&quot;headerlink&quot; title=&quot;2. 垃圾收集的算法分析&quot;&gt;&lt;/a&gt;2. 垃圾收集的算法分析&lt;/h2&gt;&lt;p&gt;　　Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。&lt;br&gt;　　&lt;br&gt;　　大多数垃圾回收算法使用了根集(root set)这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。下面介绍几个常用的算法。&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;2.1. 引用计数法(Reference Counting Collector)&lt;/strong&gt; 　　&lt;br&gt;　　引用计数法是唯一没有使用根集的垃圾回收的法，该算法使用引用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。&lt;br&gt;　　基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。但引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域生，计数器减1。&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;2.2. tracing算法(Tracing Collector)&lt;/strong&gt; 　&lt;br&gt;　　tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;2.3. compacting算法(Compacting Collector)&lt;/strong&gt; 　&lt;br&gt;　　为了解决堆碎片问题，基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;2.4. copying算法(Coping Collector)&lt;/strong&gt;&lt;br&gt;　　该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。&lt;br&gt;　　一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;2.5. generation算法(Generational Collector)&lt;/strong&gt;&lt;br&gt;　　stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;2.6. adaptive算法(Adaptive Collector)&lt;/strong&gt;&lt;br&gt;　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.lookk.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer与StringBuilder之间区别</title>
    <link href="http://www.lookk.cn/2017/12/03/String%E3%80%81StringBuffer%E4%B8%8EStringBuilder%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.lookk.cn/2017/12/03/String、StringBuffer与StringBuilder之间区别/</id>
    <published>2017-12-03T03:40:59.000Z</published>
    <updated>2017-12-07T08:45:07.596Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、三者在执行速度方面的比较</strong>：StringBuilder &gt;  StringBuffer  &gt;  String</p><p><strong>2、String &lt;（StringBuffer，StringBuilder）的原因</strong></p><p>String：字符串常量</p><p>StringBuffer：字符串变量</p><p>StringBuilder：字符串变量</p><p>　   从上面的名字可以看到，String是“字符串常量”，也就是不可改变的对象。对于这句话的理解你可能会产生这样一个疑问  ，比如这段代码：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s = <span class="string">"abcd"</span>;</span><br><span class="line">s = s+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">System</span>.out.<span class="keyword">print</span>(s);<span class="comment">// result : abcd1</span></span><br></pre></td></tr></table></figure><p> 　　我们明明就是改变了String型的变量s的，为什么说是没有改变呢? 其实这是一种欺骗，JVM是这样解析这段代码的：首先创建对象s，赋予一个abcd，然后再创建一个新的对象s用来执行第二行代码，也就是说我们之前对象s并没有变化，所以我们说String类型是不可改变的对象了，由于这种机制，每当用String操作字符串时，实际上是在不断的创建新的对象，而原来的对象就会变为垃圾被GC回收掉，可想而知这样执行效率会有多底。</p><p>　　而StringBuffer与StringBuilder就不一样了，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，这样就不会像String一样创建一些而外的对象进行操作了，当然速度就快了。</p><p><strong>3.一个特殊的例子：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str </span>= “This is only a” + “ simple” + “ test”<span class="comment">;</span></span><br><span class="line"><span class="keyword">StringBuffer </span><span class="keyword">builder </span>= new <span class="keyword">StringBuilder(“This </span>is only a”).append(“simple”).append(“ test”)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>　　你会很惊讶的发现，生成str对象的速度简直太快了，而这个时候StringBuffer居然速度上根本一点都不占优势。其实这是JVM的一个把戏，实际上：</p><p>　　　　String str = “This is only a” + “ simple” + “test”;</p><p>　　　　其实就是：</p><p>　　　　String str = “This is only a simple test”;</p><p>　　　　所以不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的String对象的话，速度就没那么快了，譬如：</p><p>　　　　String str2 = “This is only a”;</p><p>　　　　String str3 = “ simple”;</p><p>　　　　String str4 = “ test”;</p><p>　　　　String str1 = str2 +str3 + str4;</p><p>　　　　这时候JVM会规规矩矩的按照原来的方式去做。</p><p><strong>4.StringBuilder与 StringBuffer</strong></p><p>　StringBuilder：线程非安全的</p><p>　StringBuffer：线程安全的</p><p>　   当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。</p><p><strong>对于三者使用的总结：</strong><br> 1.如果要操作少量的数据用 = String<br> 2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder<br>3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、三者在执行速度方面的比较&lt;/strong&gt;：StringBuilder &amp;gt;  StringBuffer  &amp;gt;  String&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、String &amp;lt;（StringBuffer，StringBuilder）的原
      
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="String" scheme="http://www.lookk.cn/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>int和integer的区别</title>
    <link href="http://www.lookk.cn/2017/12/03/int%E5%92%8Cinteger%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.lookk.cn/2017/12/03/int和integer的区别/</id>
    <published>2017-12-03T03:39:01.000Z</published>
    <updated>2017-12-07T08:40:52.699Z</updated>
    
    <content type="html"><![CDATA[<p>Integer和int的区别</p><p>1、Integer是int提供的封装类，而int是Java的基本数据类型；</p><p>2、Integer默认值是null，而int默认值是0；</p><p>3、声明为Integer的变量需要实例化，而声明为int的变量不需要实例化；</p><p> 4、Integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数值。</p><p>比较：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i1 = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">Integer</span> i2 = <span class="number">127</span>;//java在编译的时候,被翻译成-&gt; <span class="keyword">Integer</span> i5 = <span class="keyword">Integer</span>.valueOf(<span class="number">127</span>);</span><br><span class="line"><span class="keyword">Integer</span> i3 = new <span class="keyword">Integer</span>(<span class="number">127</span>);</span><br><span class="line"><span class="keyword">Integer</span> i4 = <span class="number">127</span>;</span><br><span class="line"><span class="built_in">int</span> i5 = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">Integer</span> i6 = <span class="number">128</span>;</span><br></pre></td></tr></table></figure></p><p>在上面例子中，i1==i2为true ， i1==i3为true  ，  i5==i6为false。</p><p>因为Integer和int比都会自动拆箱（jdk1.5以上）。其实java在编译Integer i2 = 127的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(127);所以关键就是看valueOf()函数了。只要看看valueOf()函数的源码就会明白了。JDK源码的valueOf函数式这样的：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下源码大家都会明白，对于-128到127之间的数，会进行缓存，Integer i2 = 127时，会将127进行缓存，下次再写Integer i4 = 127时，就会直接从缓存中取，就不会new了。所以i3==i4为true。</p><p>摘自：<br><a href="http://www.cnblogs.com/liuling/archive/2013/05/05/intAndInteger.html" target="_blank" rel="noopener">Integer与int的种种比较你知道多少？</a><br><a href="http://blog.csdn.net/sgls652709/article/details/49079767" target="_blank" rel="noopener">Integer类型与int的==比较</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Integer和int的区别&lt;/p&gt;
&lt;p&gt;1、Integer是int提供的封装类，而int是Java的基本数据类型；&lt;/p&gt;
&lt;p&gt;2、Integer默认值是null，而int默认值是0；&lt;/p&gt;
&lt;p&gt;3、声明为Integer的变量需要实例化，而声明为int的变量不需要
      
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="integer" scheme="http://www.lookk.cn/tags/integer/"/>
    
  </entry>
  
  <entry>
    <title>String 为什么是不可变的？</title>
    <link href="http://www.lookk.cn/2017/12/03/String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F/"/>
    <id>http://www.lookk.cn/2017/12/03/String-为什么是不可变的？/</id>
    <published>2017-12-03T03:37:24.000Z</published>
    <updated>2017-12-07T08:44:55.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问：String-为什么是不可变的？"><a href="#问：String-为什么是不可变的？" class="headerlink" title="问：String 为什么是不可变的？"></a>问：String 为什么是不可变的？</h2><p>答：String 不可变是因为在 J DK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问：String-为什么是不可变的？&quot;&gt;&lt;a href=&quot;#问：String-为什么是不可变的？&quot; class=&quot;headerlink&quot; title=&quot;问：String 为什么是不可变的？&quot;&gt;&lt;/a&gt;问：String 为什么是不可变的？&lt;/h2&gt;&lt;p&gt;答：Stri
      
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="String" scheme="http://www.lookk.cn/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>java的System.getProperty()方法可以获取的值</title>
    <link href="http://www.lookk.cn/2017/12/03/java%E7%9A%84System-getProperty-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E7%9A%84%E5%80%BC/"/>
    <id>http://www.lookk.cn/2017/12/03/java的System-getProperty-方法可以获取的值/</id>
    <published>2017-12-03T03:34:29.000Z</published>
    <updated>2017-12-07T08:43:29.533Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候我们需要在项目中读取外部属性文件，用到了System.getProperty(“”)方法。这个方法需要配置JVM系统属性，用键值对存储。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.version</span>Java 运行时环境版本</span><br><span class="line">java<span class="selector-class">.vendor</span>Java 运行时环境供应商</span><br><span class="line">java<span class="selector-class">.vendor</span><span class="selector-class">.url</span>Java 供应商的 URL</span><br><span class="line">java<span class="selector-class">.home</span>Java 安装目录</span><br><span class="line">java<span class="selector-class">.vm</span><span class="selector-class">.specification</span><span class="selector-class">.version</span>Java 虚拟机规范版本</span><br><span class="line">java<span class="selector-class">.vm</span><span class="selector-class">.specification</span><span class="selector-class">.vendor</span>Java 虚拟机规范供应商</span><br><span class="line">java<span class="selector-class">.vm</span><span class="selector-class">.specification</span><span class="selector-class">.name</span>Java 虚拟机规范名称</span><br><span class="line">java<span class="selector-class">.vm</span><span class="selector-class">.version</span>Java 虚拟机实现版本</span><br><span class="line">java<span class="selector-class">.vm</span><span class="selector-class">.vendor</span>Java 虚拟机实现供应商</span><br><span class="line">java<span class="selector-class">.vm</span><span class="selector-class">.name</span>Java 虚拟机实现名称</span><br><span class="line">java<span class="selector-class">.specification</span><span class="selector-class">.version</span>Java 运行时环境规范版本</span><br><span class="line">java<span class="selector-class">.specification</span><span class="selector-class">.vendor</span>Java 运行时环境规范供应商</span><br><span class="line">java<span class="selector-class">.specification</span><span class="selector-class">.name</span>Java 运行时环境规范名称</span><br><span class="line">java<span class="selector-class">.class</span><span class="selector-class">.version</span>Java 类格式版本号</span><br><span class="line">java<span class="selector-class">.class</span><span class="selector-class">.path</span>Java 类路径</span><br><span class="line">java<span class="selector-class">.library</span><span class="selector-class">.path</span>加载库时搜索的路径列表</span><br><span class="line">java<span class="selector-class">.io</span><span class="selector-class">.tmpdir</span>默认的临时文件路径</span><br><span class="line">java<span class="selector-class">.compiler</span>要使用的 JIT 编译器的名称</span><br><span class="line">java<span class="selector-class">.ext</span><span class="selector-class">.dirs</span>一个或多个扩展目录的路径</span><br><span class="line">os<span class="selector-class">.name</span>操作系统的名称</span><br><span class="line">os<span class="selector-class">.arch</span>操作系统的架构</span><br><span class="line">os<span class="selector-class">.version</span>操作系统的版本</span><br><span class="line">file<span class="selector-class">.separator</span>文件分隔符（在 UNIX 系统中是“/”）</span><br><span class="line">path<span class="selector-class">.separator</span>路径分隔符（在 UNIX 系统中是“:”）</span><br><span class="line">line<span class="selector-class">.separator</span>行分隔符（在 UNIX 系统中是“/n”）</span><br><span class="line">user<span class="selector-class">.name</span>用户的账户名称</span><br><span class="line">user<span class="selector-class">.home</span>用户的主目录</span><br><span class="line">user<span class="selector-class">.dir</span>用户的当前工作目录</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多时候我们需要在项目中读取外部属性文件，用到了System.getProperty(“”)方法。这个方法需要配置JVM系统属性，用键值对存储。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="System" scheme="http://www.lookk.cn/tags/System/"/>
    
  </entry>
  
  <entry>
    <title>java获得文件路径</title>
    <link href="http://www.lookk.cn/2017/12/03/java%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/"/>
    <id>http://www.lookk.cn/2017/12/03/java获得文件路径/</id>
    <published>2017-12-03T03:33:26.000Z</published>
    <updated>2017-12-07T08:43:42.873Z</updated>
    
    <content type="html"><![CDATA[<p>1，FileTest.class.getResource(“”)<br>得到的是当前类FileTest.class文件的URI目录。不包括自己</p><p>2，FileTest.class.getResource(“/“)<br>得到的是当前的classpath的绝对URI路径。</p><p>3，Thread.currentThread().getContextClassLoader().getResource(“”)<br>得到的也是当前ClassPath的绝对URI路径。</p><p>4，FileTest.class.getClassLoader().getResource(“”)<br>得到的也是当前ClassPath的绝对URI路径。</p><p>5，ClassLoader.getSystemResource(“”)<br>得到的也是当前ClassPath的绝对URI路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1，FileTest.class.getResource(“”)&lt;br&gt;得到的是当前类FileTest.class文件的URI目录。不包括自己&lt;/p&gt;
&lt;p&gt;2，FileTest.class.getResource(“/“)&lt;br&gt;得到的是当前的classpath的绝对UR
      
    
    </summary>
    
      <category term="java" scheme="http://www.lookk.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.lookk.cn/tags/java/"/>
    
  </entry>
  
</feed>
